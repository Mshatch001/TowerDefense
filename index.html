<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Arcane Forest Defense</title>
  <style>
    :root {
      color-scheme: dark;
      --panel: #0f1b22;
      --accent: #4dd0e1;
      --text: #e3f2fd;
    }
    body {
      margin: 0;
      background: #0b141a;
      color: var(--text);
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      display: grid;
      min-height: 100vh;
      place-items: center;
    }
    .frame {
      background: var(--panel);
      border: 1px solid #1f2f38;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.4);
    }
    h1 {
      margin: 0 0 12px;
      font-size: 20px;
      letter-spacing: 0.04em;
      text-align: center;
    }
    #gameCanvas {
      background: #0f2d1e;
      border-radius: 12px;
      display: block;
    }
    .status {
      margin-top: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      color: #b6c7d3;
    }
    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(77, 208, 225, 0.12);
      color: var(--text);
      border: 1px solid rgba(77, 208, 225, 0.4);
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="frame">
    <h1>Arcane Forest Defense</h1>
    <canvas id="gameCanvas" width="800" height="540" aria-label="Tower defense canvas"></canvas>
    <div class="status">
      <span id="asset-counter">Loading assets 0/0â€¦</span>
      <span id="game-status" class="pill">Preparing</span>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const assetCounter = document.getElementById("asset-counter");
    const gameStatus = document.getElementById("game-status");

    const spriteManifest = [
      { key: "background", src: "assets/images/map_mushroom_forest.svg" },
      { key: "archer", src: "assets/images/archer.svg" },
      { key: "mage", src: "assets/images/mage.svg" },
      { key: "enemyGoblin", src: "assets/images/Goblin.svg" },
      { key: "enemyOrc", src: "assets/images/Orc.svg" },
      { key: "enemyTroll", src: "assets/images/Troll.svg" },
      { key: "enemySonic", src: "assets/images/Sonic.svg" },
    ];

    const loadedSprites = {};
    let assetsLoaded = 0;

    function updateAssetCounter() {
      assetCounter.textContent = `Loading assets ${assetsLoaded}/${spriteManifest.length}`;
    }

    function prepareTransparentSprite(image) {
      // The sprites are already transparent PNG/SVG assets, so we can reuse the
      // originally loaded image instead of re-encoding through a buffer
      // canvas. Returning the provided image guarantees we don't miss load
      // events on a second Image instance.
      return image;
    }

    function loadSprite({ key, src }) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          const prepared = prepareTransparentSprite(img);
          loadedSprites[key] = prepared;
          assetsLoaded += 1;
          updateAssetCounter();
          resolve();
        };
        img.onerror = () => reject(new Error(`Failed to load ${src}`));
        img.src = src;
      });
    }

    function loadAllSprites() {
      updateAssetCounter();
      return Promise.all(spriteManifest.map(loadSprite));
    }

    function drawBackground() {
      const bg = loadedSprites.background;
      if (bg && bg.complete && bg.naturalWidth > 0) {
        ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = "#0f2d1e";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }

    function drawTowers() {
      const towers = [
        { sprite: loadedSprites.archer, x: 120, y: 360 },
        { sprite: loadedSprites.mage, x: 620, y: 360 },
      ];
      towers.forEach(({ sprite, x, y }) => {
        if (sprite && sprite.complete) {
          ctx.drawImage(
            sprite,
            x - sprite.naturalWidth / 2,
            y - sprite.naturalHeight / 2
          );
        }
      });
    }

    function drawEnemies() {
      const enemies = [
        { sprite: loadedSprites.enemyGoblin, x: 180, y: 220 },
        { sprite: loadedSprites.enemyOrc, x: 330, y: 180 },
        { sprite: loadedSprites.enemyTroll, x: 480, y: 230 },
        { sprite: loadedSprites.enemySonic, x: 610, y: 190 },
      ];
      enemies.forEach(({ sprite, x, y }) => {
        if (sprite && sprite.complete) {
          ctx.drawImage(
            sprite,
            x - sprite.naturalWidth / 2,
            y - sprite.naturalHeight / 2
          );
        }
      });
    }

    function render() {
      drawBackground();
      drawTowers();
      drawEnemies();
      requestAnimationFrame(render);
    }

    function startGame() {
      gameStatus.textContent = "Ready";
      gameStatus.style.background = "rgba(76, 175, 80, 0.14)";
      gameStatus.style.color = "#c8e6c9";
      render();
    }

    loadAllSprites()
      .then(() => startGame())
      .catch((error) => {
        gameStatus.textContent = "Asset error";
        gameStatus.style.background = "rgba(244, 67, 54, 0.14)";
        gameStatus.style.color = "#ffcdd2";
        console.error(error);
      });
  </script>
</body>
</html>
