<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Grovefall</title>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Cinzel:wght@600;700;900&display=swap"
    rel="stylesheet"
  />

  <style>
    :root {
      color-scheme: dark;
      --panel: #0f1b22;
      --accent: #4dd0e1;
      --text: #e3f2fd;
      --error: #f44336;
    }
    body {
      margin: 0;
      background: #0b141a;
      color: var(--text);
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      display: grid;
      place-items: center;
      min-height: 100vh;
    }
    .frame {
      background: var(--panel);
      border: 1px solid #1f2f38;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 12px 36px rgba(0, 0, 0, 0.4);
      max-width: 1620px;
      width: 95%;
    }
    .title-banner {
      display: flex;
      justify-content: center;
      margin: 0 0 12px;
    }
    .title-banner img {
      max-width: 100%;
      height: auto;
      display: block;
    }
    h1 {
      position: absolute;
      left: -9999px;
      top: -9999px;
      height: 1px;
      width: 1px;
      overflow: hidden;
    }

    .game-content {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
    }
    .canvas-wrapper {
      position: relative;
      display: inline-block;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    #gameCanvas {
      background: #0f2d1e;
      display: block;
    }

    /* Portal & Crystal overlays */
    #firePortalAnimated,
    #crystalStage1,
    #crystalStage2,
    #crystalStage3,
    #crystalStage4 {
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -50%);
      display: none;
    }

    /* Updated sizes */
    #firePortalAnimated {
      width: 160px;
      height: 160px;
    }
    #crystalStage1,
    #crystalStage2,
    #crystalStage3,
    #crystalStage4 {
      width: 130px;
      height: 130px;
    }

    .hud-panel {
      flex: 1 1 300px;
      min-width: 300px;
      max-width: 300px;
      display: flex;
      flex-direction: column;
    }

    .status {
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      color: #b6c7d3;
    }
    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(77, 208, 225, 0.12);
      color: var(--text);
      border: 1px solid rgba(77, 208, 225, 0.4);
      font-weight: 600;
    }
    .hud {
      margin-top: 0;
      font-size: 14px;
    }
    .hud-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
      padding: 4px 0;
      border-bottom: 1px dashed rgba(255, 255, 255, 0.05);
    }
    .label {
      color: #b6c7d3;
      margin-right: 2px;
    }
    .value {
      color: #ffffff;
      font-weight: 600;
      margin-right: 8px;
      min-width: 30px;
    }
    .tower-selection-group {
      margin-top: 12px;
      margin-bottom: 12px;
    }
    .tower-button {
      display: block;
      width: 100%;
      margin: 6px 0;
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid rgba(141, 110, 255, 0.4);
      background: #181d25;
      color: #f5f1ff;
      cursor: pointer;
      font-size: 13px;
      text-align: left;
      transition: background-color 0.2s;
    }
    .tower-button.selected {
      background: #8e6bff;
      color: #110617;
      border-color: #8e6bff;
    }
    .hero-selection-group {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #22313b;
    }
    .hero-button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      margin: 4px 4px 0 0;
      border-radius: 6px;
      border: 1px solid rgba(77, 208, 225, 0.4);
      background: #10232e;
      color: #d6f2ff;
      cursor: pointer;
      font-size: 13px;
      transition: background 0.2s, border-color 0.2s;
    }
    .hero-button:hover {
      background: #133043;
      border-color: rgba(77, 208, 225, 0.7);
    }
    .hero-button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .hero-badge {
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(77, 208, 225, 0.14);
      border: 1px solid rgba(77, 208, 225, 0.35);
      font-weight: 700;
      font-size: 11px;
      color: #baf7ff;
    }
    .hero-info {
      font-size: 12px;
      line-height: 1.5;
      color: #c7e1ef;
      margin-top: 8px;
    }
    .instructions {
      margin-top: 4px;
      line-height: 1.4;
      color: #cfd8e3;
      font-size: 12px;
      border-top: 1px solid #22313b;
      padding-top: 8px;
    }
    #log {
      margin-top: auto;
      max-height: 140px;
      overflow-y: auto;
      font-size: 11px;
      border-top: 1px solid #22313b;
      padding-top: 4px;
    }
    #log div {
      margin-bottom: 2px;
      color: #b0c4ff;
    }
    .hp-bar-outer {
      flex-grow: 1;
      height: 10px;
      border-radius: 999px;
      background: rgba(10, 20, 30, 0.9);
      border: 1px solid rgba(109, 247, 255, 0.4);
      overflow: hidden;
    }
    .hp-bar-inner {
      height: 100%;
      border-radius: 999px;
      background: linear-gradient(
        90deg,
        #6df7ff,
        #a6ffb3,
        #ffc966
      );
      width: 100%;
      transition: width 0.25s ease-out;
    }
  </style>
</head>
<body>
  <div class="frame">
    <div class="title-banner">
      <img src="assets/images/Grovefall_banner.png" alt="Grovefall" />
    </div>
    <h1>Grovefall</h1>

    <div class="game-content">
      <div class="canvas-wrapper">
        <canvas id="gameCanvas" width="1280" height="1280" aria-label="Tower defense canvas"></canvas>

        <img
          id="firePortalAnimated"
          src="assets/images/Fire_Portal.svg"
          alt="Fire Portal"
        />

        <img
          id="crystalStage1"
          src="assets/images/MagicCrystal_stage1.svg"
          alt="Crystal Stage 1"
        />
        <img
          id="crystalStage2"
          src="assets/images/MagicCrystal_stage2.svg"
          alt="Crystal Stage 2"
        />
        <img
          id="crystalStage3"
          src="assets/images/MagicCrystal_stage3.svg"
          alt="Crystal Stage 3"
        />
        <img
          id="crystalStage4"
          src="assets/images/MagicCrystal_stage4.svg"
          alt="Crystal Stage 4"
        />
      </div>

      <div class="hud-panel">
        <div class="status">
          <span id="asset-counter">Loading assets 0/0…</span>
          <span id="game-status" class="pill">Preparing</span>
        </div>

        <div class="hud">
          <div class="hud-row">
            <span class="label">Wave:</span> <span class="value" id="waveValue">1</span>
            <span class="label">Gold:</span> <span class="value" id="goldValue">100</span>
            <span class="label">Lives:</span> <span class="value" id="livesValue">10</span>
          </div>
          <div class="hud-row">
            <span class="label">Enemies Remaining:</span> <span class="value" id="enemiesValue">0</span>
          </div>
          <div class="hud-row">
            <span class="label">Crystal HP:</span>
            <div class="hp-bar-outer">
              <div class="hp-bar-inner" id="crystalHpFill"></div>
            </div>
            <span class="value" id="crystalHpText">10 / 10</span>
          </div>

          <div class="tower-selection-group">
            <span class="label">Towers:</span>
            <button class="tower-button selected" data-tower-type="arrow">Archer Tower (25g)</button>
            <button class="tower-button" data-tower-type="mage">Mage Tower (40g)</button>
            <button class="tower-button" data-tower-type="sonic">Sonic Tower (60g)</button>
          </div>

          <div class="instructions">
            • Click on the <strong>grass</strong> to place towers. (Cannot build on the path!)<br />
            • <strong>Archer:</strong> Fast fire rate, low damage.<br />
            • <strong>Mage:</strong> Slower fire rate, high damage.<br />
            • <strong>Sonic:</strong> Low damage, applies a brief <strong>stun</strong> effect.<br />
          </div>

          <div class="hero-selection-group">
            <div class="hud-row" style="border: none; padding: 0; margin-bottom: 6px;">
              <span class="label">Heroes:</span>
              <span class="pill">Summon at the crystal</span>
            </div>
            <button class="hero-button" id="summonGuardian">
              <span class="hero-badge">Guardian</span>
              <span>Send the brave guardian (80g)</span>
            </button>
            <button class="hero-button" id="summonMage">
              <span class="hero-badge">Mage</span>
              <span>Send the fire mage (90g)</span>
            </button>
            <div class="hero-info">
              • Heroes walk the monster path in reverse to meet the enemies.<br />
              • They have hearty health but will retreat when exhausted.<br />
              • Guardian is melee; Mage launches long-range fireballs.
            </div>
          </div>
        </div>

        <div id="log"></div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const assetCounter = document.getElementById("asset-counter");
    const gameStatus = document.getElementById("game-status");

    const waveValue = document.getElementById("waveValue");
    const goldValue = document.getElementById("goldValue");
    const livesValue = document.getElementById("livesValue");
    const enemiesValue = document.getElementById("enemiesValue");
    const logDiv = document.getElementById("log");

    const portalImg = document.getElementById("firePortalAnimated");

    const crystalStages = [
      document.getElementById("crystalStage1"),
      document.getElementById("crystalStage2"),
      document.getElementById("crystalStage3"),
      document.getElementById("crystalStage4"),
    ];

    let crystalHits = 0; // 0–10 hits; 10 = destroyed

    const crystalHpFill = document.getElementById("crystalHpFill");
    const crystalHpText = document.getElementById("crystalHpText");

    function currentCrystalStage() {
      const maxHp = 10;
      const currentLives = Math.max(0, maxHp - crystalHits);
      if (currentLives > 7) return 1; // 8-10 lives
      if (currentLives > 4) return 2; // 5-7 lives
      if (currentLives > 1) return 3; // 2-4 lives
      return 4; // 0-1 lives (critical)
    }

    function updateCrystalStage() {
      const stageIndex = currentCrystalStage() - 1;
      crystalStages.forEach((img, idx) => {
        if (!img) return;
        img.style.display = idx === stageIndex ? "block" : "none";
      });
    }

    function updateCrystalHpUi() {
      const maxHp = 10;
      const hp = Math.max(0, maxHp - crystalHits);
      const pct = (hp / maxHp) * 100;
      if (crystalHpFill) crystalHpFill.style.width = `${pct}%`;
      if (crystalHpText) crystalHpText.textContent = `${hp} / ${maxHp}`;
    }

    // --- Audio ---

    const bgMusic = new Audio("assets/audio/WhisperingGroves.mp3");
    bgMusic.loop = true;
    bgMusic.volume = 0.5;

    let musicStarted = false;
    let musicShouldPlay = false;

    function requestMusicStart() {
      musicShouldPlay = true;
      tryStartMusic();
    }

    function tryStartMusic() {
      if (musicStarted || !musicShouldPlay) return;
      bgMusic.play()
        .then(() => {
          musicStarted = true;
        })
        .catch(() => {
          // Autoplay blocked; try again on next interaction
        });
    }

    function stopMusic() {
      bgMusic.pause();
      bgMusic.currentTime = 0;
    }

    const arrowSfx = new Audio("assets/audio/arrowsound.mp3");
    arrowSfx.volume = 0.55;

    const mageOrbSfx = new Audio("assets/audio/mageorbsound.mp3");
    mageOrbSfx.volume = 0.30;

    const sonicSfx = new Audio("assets/audio/sonicsound.mp3");
    sonicSfx.volume = 0.20;

    const goblinDamageSfx = new Audio("assets/audio/goblindamaged.mp3");
    goblinDamageSfx.volume = 0.45;

    const orcDamageSfx = new Audio("assets/audio/Orcdamaged.mp3");
    orcDamageSfx.volume = 0.50;

    const trollDamageSfx = new Audio("assets/audio/Trolldamaged.mp3");
    trollDamageSfx.volume = 0.55;

    const crystalDamageStage1Sfx = new Audio("assets/audio/crystaldamagestage1.mp3");
    crystalDamageStage1Sfx.volume = 0.55;

    const crystalDamageStage2Sfx = new Audio("assets/audio/crystaldamagestage2.mp3");
    crystalDamageStage2Sfx.volume = 0.6;

    const crystalDamageStage3Sfx = new Audio("assets/audio/crystaldamagestage3.mp3");
    crystalDamageStage3Sfx.volume = 0.65;

    const crystalDamageStage4Sfx = new Audio("assets/audio/crystaldamagestage4.mp3");
    crystalDamageStage4Sfx.volume = 0.7;

    function playCrystalDamageSfx() {
      const stage = currentCrystalStage();
      if (stage === 1) {
        playSfxWithVariation(crystalDamageStage1Sfx, 0.97, 1.03);
      } else if (stage === 2) {
        playSfxWithVariation(crystalDamageStage2Sfx, 0.96, 1.04);
      } else if (stage === 3) {
        playSfxWithVariation(crystalDamageStage3Sfx, 0.95, 1.05);
      } else {
        playSfxWithVariation(crystalDamageStage4Sfx, 0.95, 1.05);
      }
    }

    const victorySfx = new Audio("assets/audio/Victory.mp3");
    victorySfx.volume = 0.7;

    const defeatSfx = new Audio("assets/audio/Defeat.mp3");
    defeatSfx.volume = 0.7;

    function playSfxWithVariation(audio, minRate, maxRate) {
      try {
        const rate = minRate + Math.random() * (maxRate - minRate);
        const clone = audio.cloneNode();
        clone.playbackRate = rate;
        clone.play().catch(() => {});
      } catch (e) {}
    }

    function playEnemyDeathSfx(spriteKey) {
      if (spriteKey === "enemyGoblin") {
        playSfxWithVariation(goblinDamageSfx, 0.95, 1.05);
      } else if (spriteKey === "enemyOrc") {
        playSfxWithVariation(orcDamageSfx, 0.94, 1.06);
      } else if (spriteKey === "enemyTroll") {
        playSfxWithVariation(trollDamageSfx, 0.95, 1.05);
      }
    }

    function log(message) {
      const div = document.createElement("div");
      const time = new Date().toLocaleTimeString();
      div.textContent = "[" + time + "] " + message;
      logDiv.prepend(div);
    }

    const spriteManifest = [
      { key: "background",  src: "assets/images/map_mushroom_forest.svg" },
      { key: "archer",      src: "assets/images/archer.svg" },
      { key: "mage",        src: "assets/images/mage.svg" },
      { key: "heroGuardian", src: "assets/images/Hero_Guardian.PNG" },
      { key: "heroMage",     src: "assets/images/Hero_Mage.PNG" },
      { key: "enemyGoblin", src: "assets/images/Goblin.svg" },
      { key: "enemyOrc",    src: "assets/images/Orc.svg" },
      { key: "enemyTroll",  src: "assets/images/Troll.svg" },
      { key: "sonicTower",  src: "assets/images/Sonic.svg" }
    ];

    const loadedSprites = {};
    let assetsLoaded = 0;

    function updateAssetCounter() {
      assetCounter.textContent = `Loading assets ${assetsLoaded}/${spriteManifest.length}`;
    }

    function loadSprite({ key, src }) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          loadedSprites[key] = img;
          assetsLoaded += 1;
          updateAssetCounter();
          resolve();
        };
        img.onerror = () => {
          console.error(`Failed to load ${src}`);
          reject(new Error(`Failed to load ${src}`));
        };
        img.src = src;
      });
    }

    function loadAllSprites() {
      updateAssetCounter();
      return Promise.all(spriteManifest.map(loadSprite));
    }

    const colors = {
      path: "rgba(160, 120, 70, 0.55)",
      grass: "#142010",
      arrowCore: "#C6FF7A",
      arrowTrail: "rgba(166,255,176,0.55)",
      magicCore: "#FFFFFF",
      magicInner: "#B47CFF",
      magicOuter: "rgba(132,243,255,0.8)",
      magicTrail: "rgba(180,124,255,0.7)",
      fireballCore: "#ffebc7",
      fireballInner: "#ffb347",
      fireballOuter: "rgba(255, 94, 58, 0.85)",
      fireballTrail: "rgba(255, 181, 94, 0.65)"
    };

    const GRID_SIZE = 40; // 1280 / 32
    const MAP_COLS = canvas.width / GRID_SIZE; // 32
    const MAP_ROWS = canvas.height / GRID_SIZE; // 32

    // Cleaned path: using your grid comments as truth.
    // Grid -> Canvas: x = (col + 0.5) * 40, y = (row + 0.5) * 40
    const path = [
      { x: (4 + 0.5) * GRID_SIZE,  y: (5 + 0.5) * GRID_SIZE },

      { x: (11 + 0.5) * GRID_SIZE,  y: (11 + 0.5) * GRID_SIZE },

      { x: (23 + 0.5) * GRID_SIZE, y: (9 + 0.5) * GRID_SIZE },

      { x: (17 + 0.5) * GRID_SIZE, y: (18 + 0.5) * GRID_SIZE },

      { x: (7 + 0.5) * GRID_SIZE, y: (20 + 0.5) * GRID_SIZE },

      { x: (7 + 0.5) * GRID_SIZE, y: (23 + 0.5) * GRID_SIZE },

      { x: (22 + 0.5) * GRID_SIZE, y: (23 + 0.5) * GRID_SIZE },

      { x: (30 + 0.3) * GRID_SIZE, y: (29 + 0.5) * GRID_SIZE },
    ];
    const goal = path[path.length - 1];

    let gold = 100;
    let lives = 10;
    let wave = 1;

    let towers = [];
    let enemies = [];
    let projectiles = [];
    let hero = null;

    const heroConfigs = {
      guardian: {
        name: "Guardian Hero",
        cost: 80,
        speed: 75,
        hp: 120,
        damage: 5,
        range: 70,
        attackRate: 650,
        enemyDamagePerSecond: 3,
        spriteKey: "heroGuardian"
      },
      mage: {
        name: "Mage Hero",
        cost: 90,
        speed: 85,
        hp: 100,
        damage: 6,
        range: 180,
        attackRate: 750,
        enemyDamagePerSecond: 2.5,
        spriteKey: "heroMage"
      }
    };

    let spawnTimer = 0;
    let spawnInterval = 1400;
    let enemiesToSpawn = 5;
    let lastFrameTime = performance.now();

    let selectedTowerType = "arrow";

    let gameWon = false;
    let gameEnded = false;

    const towerButtons = document.querySelectorAll(".tower-button");
    const summonGuardianBtn = document.getElementById("summonGuardian");
    const summonMageBtn = document.getElementById("summonMage");
    towerButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        towerButtons.forEach((b) => b.classList.remove("selected"));
        btn.classList.add("selected");
        selectedTowerType = btn.dataset.towerType;
        tryStartMusic();
      });
    });

    summonGuardianBtn?.addEventListener("click", () => summonHero("guardian"));
    summonMageBtn?.addEventListener("click", () => summonHero("mage"));

    function updateHeroButtons() {
      const active = !!hero;
      if (summonGuardianBtn) {
        const cfg = heroConfigs.guardian;
        summonGuardianBtn.disabled = active || gold < cfg.cost;
      }
      if (summonMageBtn) {
        const cfg = heroConfigs.mage;
        summonMageBtn.disabled = active || gold < cfg.cost;
      }
    }

    canvas.addEventListener("click", placeTowerFromClick);

    function placeTowerFromClick(event) {
      if (lives <= 0 || gameEnded) {
        log("The game is over. Refresh the page to play again.");
        return;
      }

      tryStartMusic();

      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (event.clientX - rect.left) * scaleX;
      const y = (event.clientY - rect.top) * scaleY;

      const gridX = Math.floor(x / GRID_SIZE);
      const gridY = Math.floor(y / GRID_SIZE);

      if (isOnPath(gridX, gridY)) {
        log("You cannot build on the enemy path.");
        return;
      }
      if (towers.some((t) => t.gridX === gridX && t.gridY === gridY)) {
        log("There is already a tower there.");
        return;
      }

      const cfg = getTowerConfig(selectedTowerType);
      if (gold < cfg.cost) {
        log("Not enough gold to build " + cfg.name + ".");
        return;
      }

      gold -= cfg.cost;
      goldValue.textContent = gold;
      updateHeroButtons();

      towers.push({
        type: selectedTowerType,
        name: cfg.name,
        gridX,
        gridY,
        x: gridX * GRID_SIZE + GRID_SIZE / 2,
        y: gridY * GRID_SIZE + GRID_SIZE / 2,
        range: cfg.range,
        fireRate: cfg.fireRate,
        cooldown: 0,
        projectileSpeed: cfg.projectileSpeed,
        damage: cfg.damage,
        effect: cfg.effect || null
      });

      log("Built " + cfg.name + " at (" + gridX + ", " + gridY + ").");
    }

    function isOnPath(gx, gy) {
      const cx = gx * GRID_SIZE + GRID_SIZE / 2;
      const cy = gy * GRID_SIZE + GRID_SIZE / 2;
      const maxDist = GRID_SIZE * 0.6;

      for (let i = 0; i < path.length - 1; i++) {
        const a = path[i];
        const b = path[i + 1];
        const dist = distancePointToSegment(cx, cy, a.x, a.y, b.x, b.y);
        if (dist < maxDist) return true;
      }
      return false;
    }

    function distancePointToSegment(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      if (dx === 0 && dy === 0) {
        return Math.hypot(px - x1, py - y1);
      }
      const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
      const tt = Math.max(0, Math.min(1, t));
      const projX = x1 + tt * dx;
      const projY = y1 + tt * dy;
      return Math.hypot(px - projX, py - projY);
    }

    function getTowerConfig(type) {
      if (type === "mage") {
        return {
          name: "Mage Tower",
          cost: 40,
          range: 150,
          fireRate: 900,
          projectileSpeed: 260,
          damage: 3
        };
      }

      if (type === "sonic") {
        return {
          name: "Sonic Tower",
          cost: 60,
          range: 180,
          fireRate: 650,
          projectileSpeed: 500,
          damage: 1,
          effect: "stun"
        };
      }

      return {
        name: "Archer Tower",
        cost: 25,
        range: 130,
        fireRate: 450,
        projectileSpeed: 360,
        damage: 1
      };
    }

    function spawnEnemy() {
      const baseHp = 5 + wave * 1.5;
      const speed = 45 + wave * 3;

      const enemyKeys = ["enemyGoblin", "enemyOrc", "enemyTroll"];
      const spriteKey = enemyKeys[Math.floor(Math.random() * enemyKeys.length)];

      enemies.push({
        x: path[0].x,
        y: path[0].y,
        waypointIndex: 0,
        speed,
        hp: baseHp,
        maxHp: baseHp,
        spriteKey,
        stunnedUntil: 0
      });

      requestMusicStart();
    }

    function update(dt) {
      if (gameEnded) return;

      if (enemiesToSpawn > 0) {
        spawnTimer += dt * 1000;
        if (spawnTimer >= spawnInterval) {
          spawnTimer = 0;
          spawnEnemy();
          enemiesToSpawn -= 1;
        }
      } else if (enemies.length === 0) {

        if (wave >= 10) {
          log("You have vanquished the final wave of Grovefall!");
          stopMusic();
          victorySfx.play().catch(()=>{});
          gameWon = true;
          gameEnded = true;
          return;
        }

        wave += 1;
        waveValue.textContent = wave;
        enemiesToSpawn = 5 + wave * 2;
        spawnInterval = Math.max(500, 1400 - wave * 60);
        log("Wave " + wave + " is approaching.");
      }

      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        moveEnemy(e, dt);
        if (reachedGoal(e)) {
          enemies.splice(i, 1);

          crystalHits = Math.min(10, crystalHits + 1);
          updateCrystalStage();
          updateCrystalHpUi();
          playCrystalDamageSfx();

          lives -= 1;
          livesValue.textContent = lives;
          log("An enemy reached the crystal. Lives left: " + lives);
          if (lives <= 0 && !gameEnded) {
            log("The crystal has fallen. Grovefall is lost.");
            stopMusic();
            defeatSfx.play().catch(()=>{});
            gameEnded = true;
          }
        }
      }

      towers.forEach((t) => {
        t.cooldown -= dt * 1000;
        if (t.cooldown <= 0 && enemies.length > 0 && lives > 0 && !gameEnded) {
          const target = findTargetForTower(t);
          if (target) {
            fireAtTarget(t, target);
          }
        }
      });

      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        const dx = p.tx - p.x;
        const dy = p.ty - p.y;
        const dist = Math.hypot(dx, dy);
        const step = p.speed * dt;
        if (dist <= step || dist === 0) {
          if (p.target && enemies.includes(p.target)) {
            if (p.effect === "stun") {
              p.target.stunnedUntil = Date.now() + 600;
            }

            p.target.hp -= p.damage;
            if (p.target.hp <= 0) {
              playEnemyDeathSfx(p.target.spriteKey);

              const idx = enemies.indexOf(p.target);
              if (idx >= 0) {
                enemies.splice(idx, 1);
                const reward = 3 + Math.floor(wave / 2);
                gold += reward;
                goldValue.textContent = gold;
                updateHeroButtons();
                log("Enemy defeated. +" + reward + " gold.");
              }
            }
          }
          projectiles.splice(i, 1);
        } else {
          p.x += (dx / dist) * step;
          p.y += (dy / dist) * step;
        }
      }

      updateHero(dt);
      enemiesValue.textContent = enemies.length + enemiesToSpawn;
    }

    function findNearestEnemyToPoint(px, py) {
      let nearest = null;
      let bestDist = Infinity;
      enemies.forEach((e) => {
        const dx = e.x - px;
        const dy = e.y - py;
        const dist = Math.hypot(dx, dy);
        if (dist < bestDist) {
          bestDist = dist;
          nearest = e;
        }
      });
      return { target: nearest, distance: bestDist };
    }

    function updateHero(dt) {
      if (!hero) return;

      hero.cooldown -= dt * 1000;

      const { target, distance } = findNearestEnemyToPoint(hero.x, hero.y);

      if (target) {
        // Enemies nearby will chip away at the hero over time
        enemies.forEach((e) => {
          const threatDist = Math.hypot(e.x - hero.x, e.y - hero.y);
          if (threatDist < hero.range + 40) {
            hero.hp -= hero.enemyDamagePerSecond * dt;
          }
        });

        if (distance > hero.range * 0.9) {
          movePointTowards(hero, target.x, target.y, hero.speed * dt);
        } else if (hero.cooldown <= 0) {
          if (hero.type === "mage") {
            projectiles.push({
              x: hero.x,
              y: hero.y,
              tx: target.x,
              ty: target.y,
              target,
              speed: 320,
              damage: hero.damage,
              kind: "heroFireball"
            });
          } else {
            target.hp -= hero.damage;
            if (target.hp <= 0) {
              playEnemyDeathSfx(target.spriteKey);
              const idx = enemies.indexOf(target);
              if (idx >= 0) {
                enemies.splice(idx, 1);
                const reward = 5 + Math.floor(wave / 2);
                gold += reward;
                goldValue.textContent = gold;
                updateHeroButtons();
                log(hero.name + " defeated an enemy! +" + reward + " gold.");
              }
            }
          }
          hero.cooldown = hero.attackRate;
        }
      } else {
        advanceHeroAlongPath(dt);
      }

      if (hero.hp <= 0) {
        log(hero.name + " is too tired and vanishes in a puff of sparkles.");
        hero = null;
        updateHeroButtons();
      }
    }

    function movePointTowards(obj, tx, ty, step) {
      const dx = tx - obj.x;
      const dy = ty - obj.y;
      const dist = Math.hypot(dx, dy);
      if (dist <= step || dist === 0) {
        obj.x = tx;
        obj.y = ty;
      } else {
        obj.x += (dx / dist) * step;
        obj.y += (dy / dist) * step;
      }
    }

    function advanceHeroAlongPath(dt) {
      if (!hero) return;
      if (hero.waypointIndex <= 0) return;
      const target = path[hero.waypointIndex - 1];
      movePointTowards(hero, target.x, target.y, hero.speed * dt);
      const dx = target.x - hero.x;
      const dy = target.y - hero.y;
      if (Math.hypot(dx, dy) < 2) {
        hero.waypointIndex = Math.max(0, hero.waypointIndex - 1);
      }
    }

    function moveEnemy(e, dt) {
      const now = Date.now();
      if (e.stunnedUntil && now < e.stunnedUntil) {
        return;
      }

      if (e.waypointIndex >= path.length - 1) return;
      const target = path[e.waypointIndex + 1];
      const dx = target.x - e.x;
      const dy = target.y - e.y;
      const dist = Math.hypot(dx, dy);
      const step = e.speed * dt;
      if (step >= dist && dist !== 0) {
        e.x = target.x;
        e.y = target.y;
        e.waypointIndex += 1;
      } else if (dist > 0) {
        e.x += (dx / dist) * step;
        e.y += (dy / dist) * step;
      }
    }

    function summonHero(type) {
      const cfg = heroConfigs[type];
      if (!cfg) return;
      if (hero) {
        log("A hero is already traveling the path!");
        return;
      }
      if (gold < cfg.cost) {
        log("Not enough gold to send " + cfg.name + ".");
        return;
      }

      gold -= cfg.cost;
      goldValue.textContent = gold;
      updateHeroButtons();

      hero = {
        type,
        name: cfg.name,
        x: goal.x,
        y: goal.y,
        waypointIndex: path.length - 1,
        speed: cfg.speed,
        hp: cfg.hp,
        maxHp: cfg.hp,
        damage: cfg.damage,
        range: cfg.range,
        attackRate: cfg.attackRate,
        cooldown: 0,
        spriteKey: cfg.spriteKey,
        enemyDamagePerSecond: cfg.enemyDamagePerSecond,
        state: "advancing"
      };

      log(cfg.name + " has been summoned! They are marching from the crystal.");
    }

    function reachedGoal(e) {
      const dx = e.x - goal.x;
      const dy = e.y - goal.y;
      return Math.hypot(dx, dy) < 14;
    }

    function findTargetForTower(tower) {
      let nearest = null;
      let bestDist = Infinity;
      enemies.forEach((e) => {
        const dx = e.x - tower.x;
        const dy = e.y - tower.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= tower.range && dist < bestDist) {
          bestDist = dist;
          nearest = e;
        }
      });
      return nearest;
    }

    function fireAtTarget(tower, target) {
      tower.cooldown = tower.fireRate;

      if (tower.type === "mage") {
        playSfxWithVariation(mageOrbSfx, 0.95, 1.05);
      } else if (tower.type === "sonic") {
        playSfxWithVariation(sonicSfx, 0.90, 1.10);
      } else {
        playSfxWithVariation(arrowSfx, 0.92, 1.08);
      }

      projectiles.push({
        x: tower.x,
        y: tower.y,
        tx: target.x,
        ty: target.y,
        target: target,
        speed: tower.projectileSpeed,
        damage: tower.damage,
        kind: tower.type,
        effect: tower.effect || null
      });
    }

    function drawBackground() {
      const bg = loadedSprites.background;
      if (bg && bg.complete && bg.naturalWidth > 0) {
        ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = colors.grass;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      ctx.lineWidth = GRID_SIZE * 0.65;
      ctx.strokeStyle = colors.path;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
      }
      ctx.stroke();
    }

    function drawSpriteNormalized(sprite, x, y, maxSize) {
      if (!sprite || !sprite.complete || sprite.naturalWidth === 0) return;
      const w = sprite.naturalWidth;
      const h = sprite.naturalHeight;
      const scale = maxSize / Math.max(w, h);
      const drawWidth = w * scale;
      const drawHeight = h * scale;
      ctx.drawImage(
        sprite,
        x - drawWidth / 2,
        y - drawHeight / 2,
        drawWidth,
        drawHeight
      );
    }

    function drawTowers(time) {
      const TOWER_SIZE = GRID_SIZE * 4; // tower size set to 1.4 as requested
      towers.forEach((t) => {
        ctx.beginPath();
        ctx.strokeStyle = "rgba(255,255,255,0.06)";
        ctx.lineWidth = 1;
        ctx.arc(t.x, t.y, t.range, 0, Math.PI * 2);
        ctx.stroke();

        if (t.type === "mage") {
          drawSpriteNormalized(loadedSprites.mage, t.x, t.y, TOWER_SIZE);
        } else if (t.type === "sonic") {
          drawSpriteNormalized(loadedSprites.sonicTower, t.x, t.y, TOWER_SIZE);
        } else {
          drawSpriteNormalized(loadedSprites.archer, t.x, t.y, TOWER_SIZE);
        }
      });
    }

    function drawHero() {
      if (!hero) return;
      const HERO_SIZE = GRID_SIZE * 2.2;
      const sprite = loadedSprites[hero.spriteKey];
      drawSpriteNormalized(sprite, hero.x, hero.y, HERO_SIZE);

      const barWidth = GRID_SIZE * 1.2;
      const barHeight = 8;
      const hpRatio = hero.hp / hero.maxHp;
      const bx = hero.x - barWidth / 2;
      const by = hero.y - HERO_SIZE * 0.45;
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(bx, by, barWidth, barHeight);
      ctx.fillStyle = "#ffe66d";
      ctx.fillRect(bx, by, barWidth * Math.max(0, hpRatio), barHeight);
    }

    function drawEnemies() {
      const ENEMY_SIZE = GRID_SIZE * 1.4;
      enemies.forEach((e) => {
        const sprite =
          loadedSprites[e.spriteKey] || loadedSprites.enemyGoblin || null;
        drawSpriteNormalized(sprite, e.x, e.y, ENEMY_SIZE);

        const barWidth = GRID_SIZE * 0.7;
        const barHeight = 5;
        const hpRatio = e.hp / e.maxHp;
        const bx = e.x - barWidth / 2;
        const by = e.y - ENEMY_SIZE * 0.4;
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(bx, by, barWidth, barHeight);
        ctx.fillStyle = "#5eff7b";
        ctx.fillRect(bx, by, barWidth * Math.max(0, hpRatio), barHeight);

        if (e.stunnedUntil > Date.now()) {
          ctx.fillStyle = "rgba(173, 216, 255, 0.6)";
          ctx.beginPath();
          ctx.arc(e.x, e.y - ENEMY_SIZE / 2, 5, 0, Math.PI * 2);
          ctx.fill();
        }
      });
    }

    function drawProjectiles() {
        projectiles.forEach((p) => {
          if (p.kind === "mage") {
            const radius = 5;
            const gradient = ctx.createRadialGradient(
              p.x, p.y, 0,
              p.x, p.y, radius
            );
            gradient.addColorStop(0, colors.magicCore);
            gradient.addColorStop(0.4, colors.magicInner);
            gradient.addColorStop(1, colors.magicOuter);
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = colors.magicTrail;
            ctx.lineWidth = 2;
            const trailLength = 10;
            const dx = p.tx - p.x;
            const dy = p.ty - p.y;
            const dist = Math.hypot(dx, dy) || 1;
            const ux = dx / dist;
            const uy = dy / dist;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x - ux * trailLength, p.y - uy * trailLength);
            ctx.stroke();
          } else if (p.kind === "heroFireball") {
            const radius = 7;
            const gradient = ctx.createRadialGradient(
              p.x, p.y, 0,
              p.x, p.y, radius
            );
            gradient.addColorStop(0, colors.fireballCore);
            gradient.addColorStop(0.5, colors.fireballInner);
            gradient.addColorStop(1, colors.fireballOuter);
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = colors.fireballTrail;
            ctx.lineWidth = 2;
            const trailLength = 14;
            const dx = p.tx - p.x;
            const dy = p.ty - p.y;
            const dist = Math.hypot(dx, dy) || 1;
            const ux = dx / dist;
            const uy = dy / dist;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x - ux * trailLength, p.y - uy * trailLength);
            ctx.stroke();
          } else if (p.kind === "sonic") {
            const radius = 8;
            ctx.strokeStyle = "rgba(173, 216, 255, 0.9)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
          ctx.stroke();

          ctx.strokeStyle = "rgba(173, 216, 255, 0.4)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius + 4, 0, Math.PI * 2);
          ctx.stroke();
        } else {
          const dx = p.tx - p.x;
          const dy = p.ty - p.y;
          const dist = Math.hypot(dx, dy) || 1;
          const ux = dx / dist;
          const uy = dy / dist;

          const arrowLength = 14;
          const tipX = p.x + ux * arrowLength;
          const tipY = p.y + uy * arrowLength;

          ctx.strokeStyle = colors.arrowTrail;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.x - ux * 6, p.y - uy * 6);
          ctx.lineTo(p.x, p.y);
          ctx.stroke();

          ctx.strokeStyle = colors.arrowCore;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(tipX, tipY);
          ctx.stroke();

          ctx.fillStyle = colors.arrowCore;
          ctx.beginPath();
          ctx.moveTo(tipX, tipY);
          ctx.lineTo(
            tipX - uy * 3 - ux * 3,
            tipY + ux * 3 - uy * 3
          );
          ctx.lineTo(
            tipX + uy * 3 - ux * 3,
            tipY - ux * 3 - uy * 3
          );
          ctx.closePath();
          ctx.fill();
        }
      });
    }

    function drawGameOverOverlay() {
      ctx.save();
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#ffffff";
      ctx.textAlign = "center";

      ctx.font = "bold 40px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
      ctx.fillText("Game Over", canvas.width / 2, canvas.height / 2 - 20);

      ctx.font = "16px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif";
      ctx.fillText(`Waves survived: ${wave}`, canvas.width / 2, canvas.height / 2 + 10);
      ctx.fillText("Refresh the page to play again.", canvas.width / 2, canvas.height / 2 + 36);

      ctx.restore();
    }

    function drawVictoryOverlay() {
      ctx.save();
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#d0ffb3";
      ctx.textAlign = "center";

      ctx.font = "bold 42px system-ui";
      ctx.fillText("Victory!", canvas.width / 2, canvas.height / 2 - 20);

      ctx.font = "18px system-ui";
      ctx.fillText("You have defended Grovefall through all 10 waves.", canvas.width / 2, canvas.height / 2 + 10);
      ctx.fillText("Refresh the page to play again.", canvas.width / 2, canvas.height / 2 + 40);

      ctx.restore();
    }

    function draw(timestamp) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      drawTowers(timestamp);
      drawHero();
      drawEnemies();
      drawProjectiles();

      if (gameWon) {
        drawVictoryOverlay();
      } else if (lives <= 0) {
        drawGameOverOverlay();
      }
    }

    function gameLoop(timestamp) {
      const dt = (timestamp - lastFrameTime) / 1000;
      lastFrameTime = timestamp;

      if (!gameEnded && lives > 0) {
        update(dt);
      }
      draw(timestamp);
      requestAnimationFrame(gameLoop);
    }

    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
      };
    }

    loadAllSprites()
      .then(() => {
        gameStatus.textContent = "Ready";
        gameStatus.style.background = "rgba(76, 175, 80, 0.14)";
        gameStatus.style.color = "#c8e6c9";

        log("Welcome to Grovefall.");
        log("Archer, Mage, and Sonic Towers are ready to be placed.");
        log("Enemies emerge from the fire portal and seek the magic crystal.");
        log("Summon the Guardian or Mage hero from the crystal to push back!");

        const spawn = path[0];
        if (portalImg) {
          portalImg.style.left = `${spawn.x}px`;
          portalImg.style.top  = `${spawn.y}px`;
          portalImg.style.display = 'block';
        }

        crystalStages.forEach(img => {
          if (img) {
            img.style.left = `${goal.x}px`;
            img.style.top  = `${goal.y}px`;
          }
        });

        waveValue.textContent = wave;
        goldValue.textContent = gold;
        livesValue.textContent = lives;
        updateHeroButtons();

        crystalHits = 0;
        updateCrystalStage();
        updateCrystalHpUi();

        lastFrameTime = performance.now();
        requestAnimationFrame(gameLoop);
      })
      .catch((error) => {
        gameStatus.textContent = "Asset error";
        gameStatus.style.background = "rgba(244, 67, 54, 0.14)";
        gameStatus.style.color = "#ffcdd2";
        console.error("Game failed to load assets:", error);
      });

    document.addEventListener('click', tryStartMusic, { once: true });
    document.addEventListener('keydown', tryStartMusic, { once: true });
  </script>
</body>
</html>
